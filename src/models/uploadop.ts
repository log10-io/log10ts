/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  Feedback,
  Feedback$inboundSchema,
  Feedback$Outbound,
  Feedback$outboundSchema,
} from "./feedback.js";
import {
  HTTPMetadata,
  HTTPMetadata$inboundSchema,
  HTTPMetadata$Outbound,
  HTTPMetadata$outboundSchema,
} from "./httpmetadata.js";
import { SDKValidationError } from "./sdkvalidationerror.js";

export type UploadGlobals = {
  xLog10Organization?: string | undefined;
};

export type Two = {
  /**
   * The unique identifier for this feedback.
   */
  id?: string | undefined;
  /**
   * The epoch this schema was created.
   */
  createdAtMs?: number | undefined;
  /**
   * The unique identifier for the task associated with this feedback.
   */
  taskId: string;
  /**
   * The values of the feedback. Must be valid JSON according to the task schema.
   */
  jsonValues: { [k: string]: any };
  /**
   * The matched completion ids associated with this feedback.
   */
  matchedCompletionIds?: Array<string> | undefined;
  /**
   * The comment associated with this feedback.
   */
  comment: string;
  completionsSummary?: string | undefined;
  /**
   * The unique identifier for the organization.
   */
  organizationId: string;
  /**
   * The completion ids to associate with this feedback.
   */
  completionIds: Array<string>;
};

export type RequestBody1 = {
  /**
   * The unique identifier for this feedback.
   */
  id?: string | undefined;
  /**
   * The epoch this schema was created.
   */
  createdAtMs?: number | undefined;
  /**
   * The unique identifier for the task associated with this feedback.
   */
  taskId: string;
  /**
   * The values of the feedback. Must be valid JSON according to the task schema.
   */
  jsonValues: { [k: string]: any };
  /**
   * The matched completion ids associated with this feedback.
   */
  matchedCompletionIds?: Array<string> | undefined;
  /**
   * The comment associated with this feedback.
   */
  comment: string;
  completionsSummary?: string | undefined;
  /**
   * The unique identifier for the organization.
   */
  organizationId: string;
  /**
   * Whether to allow unmatched feedback. Defaults to false.
   */
  allowUnmatchedFeedback?: boolean | undefined;
  /**
   * The maximum number of matched completions. Returns error if exceeded. Defaults to 100.
   */
  maxMatchedCompletions?: number | undefined;
  /**
   * The completion tags associated with this feedback.
   */
  completionTagsSelector: Array<string>;
};

export type UploadRequestBody = Two | RequestBody1;

export type UploadRequest = {
  xLog10Organization?: string | undefined;
  requestBody: Two | RequestBody1;
};

export type UploadResponse = {
  httpMeta: HTTPMetadata;
  /**
   * OK
   */
  feedback?: Feedback | undefined;
};

/** @internal */
export const UploadGlobals$inboundSchema: z.ZodType<
  UploadGlobals,
  z.ZodTypeDef,
  unknown
> = z.object({
  "X-Log10-Organization": z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "X-Log10-Organization": "xLog10Organization",
  });
});

/** @internal */
export type UploadGlobals$Outbound = {
  "X-Log10-Organization"?: string | undefined;
};

/** @internal */
export const UploadGlobals$outboundSchema: z.ZodType<
  UploadGlobals$Outbound,
  z.ZodTypeDef,
  UploadGlobals
> = z.object({
  xLog10Organization: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    xLog10Organization: "X-Log10-Organization",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UploadGlobals$ {
  /** @deprecated use `UploadGlobals$inboundSchema` instead. */
  export const inboundSchema = UploadGlobals$inboundSchema;
  /** @deprecated use `UploadGlobals$outboundSchema` instead. */
  export const outboundSchema = UploadGlobals$outboundSchema;
  /** @deprecated use `UploadGlobals$Outbound` instead. */
  export type Outbound = UploadGlobals$Outbound;
}

export function uploadGlobalsToJSON(uploadGlobals: UploadGlobals): string {
  return JSON.stringify(UploadGlobals$outboundSchema.parse(uploadGlobals));
}

export function uploadGlobalsFromJSON(
  jsonString: string,
): SafeParseResult<UploadGlobals, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UploadGlobals$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UploadGlobals' from JSON`,
  );
}

/** @internal */
export const Two$inboundSchema: z.ZodType<Two, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string().optional(),
    created_at_ms: z.number().optional(),
    task_id: z.string(),
    json_values: z.record(z.any()),
    matched_completion_ids: z.array(z.string()).optional(),
    comment: z.string(),
    completions_summary: z.string().optional(),
    organization_id: z.string(),
    completion_ids: z.array(z.string()),
  }).transform((v) => {
    return remap$(v, {
      "created_at_ms": "createdAtMs",
      "task_id": "taskId",
      "json_values": "jsonValues",
      "matched_completion_ids": "matchedCompletionIds",
      "completions_summary": "completionsSummary",
      "organization_id": "organizationId",
      "completion_ids": "completionIds",
    });
  });

/** @internal */
export type Two$Outbound = {
  id?: string | undefined;
  created_at_ms?: number | undefined;
  task_id: string;
  json_values: { [k: string]: any };
  matched_completion_ids?: Array<string> | undefined;
  comment: string;
  completions_summary?: string | undefined;
  organization_id: string;
  completion_ids: Array<string>;
};

/** @internal */
export const Two$outboundSchema: z.ZodType<Two$Outbound, z.ZodTypeDef, Two> = z
  .object({
    id: z.string().optional(),
    createdAtMs: z.number().optional(),
    taskId: z.string(),
    jsonValues: z.record(z.any()),
    matchedCompletionIds: z.array(z.string()).optional(),
    comment: z.string(),
    completionsSummary: z.string().optional(),
    organizationId: z.string(),
    completionIds: z.array(z.string()),
  }).transform((v) => {
    return remap$(v, {
      createdAtMs: "created_at_ms",
      taskId: "task_id",
      jsonValues: "json_values",
      matchedCompletionIds: "matched_completion_ids",
      completionsSummary: "completions_summary",
      organizationId: "organization_id",
      completionIds: "completion_ids",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Two$ {
  /** @deprecated use `Two$inboundSchema` instead. */
  export const inboundSchema = Two$inboundSchema;
  /** @deprecated use `Two$outboundSchema` instead. */
  export const outboundSchema = Two$outboundSchema;
  /** @deprecated use `Two$Outbound` instead. */
  export type Outbound = Two$Outbound;
}

export function twoToJSON(two: Two): string {
  return JSON.stringify(Two$outboundSchema.parse(two));
}

export function twoFromJSON(
  jsonString: string,
): SafeParseResult<Two, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Two$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Two' from JSON`,
  );
}

/** @internal */
export const RequestBody1$inboundSchema: z.ZodType<
  RequestBody1,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  created_at_ms: z.number().optional(),
  task_id: z.string(),
  json_values: z.record(z.any()),
  matched_completion_ids: z.array(z.string()).optional(),
  comment: z.string(),
  completions_summary: z.string().optional(),
  organization_id: z.string(),
  allow_unmatched_feedback: z.boolean().default(false),
  max_matched_completions: z.number().int().default(100),
  completion_tags_selector: z.array(z.string()),
}).transform((v) => {
  return remap$(v, {
    "created_at_ms": "createdAtMs",
    "task_id": "taskId",
    "json_values": "jsonValues",
    "matched_completion_ids": "matchedCompletionIds",
    "completions_summary": "completionsSummary",
    "organization_id": "organizationId",
    "allow_unmatched_feedback": "allowUnmatchedFeedback",
    "max_matched_completions": "maxMatchedCompletions",
    "completion_tags_selector": "completionTagsSelector",
  });
});

/** @internal */
export type RequestBody1$Outbound = {
  id?: string | undefined;
  created_at_ms?: number | undefined;
  task_id: string;
  json_values: { [k: string]: any };
  matched_completion_ids?: Array<string> | undefined;
  comment: string;
  completions_summary?: string | undefined;
  organization_id: string;
  allow_unmatched_feedback: boolean;
  max_matched_completions: number;
  completion_tags_selector: Array<string>;
};

/** @internal */
export const RequestBody1$outboundSchema: z.ZodType<
  RequestBody1$Outbound,
  z.ZodTypeDef,
  RequestBody1
> = z.object({
  id: z.string().optional(),
  createdAtMs: z.number().optional(),
  taskId: z.string(),
  jsonValues: z.record(z.any()),
  matchedCompletionIds: z.array(z.string()).optional(),
  comment: z.string(),
  completionsSummary: z.string().optional(),
  organizationId: z.string(),
  allowUnmatchedFeedback: z.boolean().default(false),
  maxMatchedCompletions: z.number().int().default(100),
  completionTagsSelector: z.array(z.string()),
}).transform((v) => {
  return remap$(v, {
    createdAtMs: "created_at_ms",
    taskId: "task_id",
    jsonValues: "json_values",
    matchedCompletionIds: "matched_completion_ids",
    completionsSummary: "completions_summary",
    organizationId: "organization_id",
    allowUnmatchedFeedback: "allow_unmatched_feedback",
    maxMatchedCompletions: "max_matched_completions",
    completionTagsSelector: "completion_tags_selector",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RequestBody1$ {
  /** @deprecated use `RequestBody1$inboundSchema` instead. */
  export const inboundSchema = RequestBody1$inboundSchema;
  /** @deprecated use `RequestBody1$outboundSchema` instead. */
  export const outboundSchema = RequestBody1$outboundSchema;
  /** @deprecated use `RequestBody1$Outbound` instead. */
  export type Outbound = RequestBody1$Outbound;
}

export function requestBody1ToJSON(requestBody1: RequestBody1): string {
  return JSON.stringify(RequestBody1$outboundSchema.parse(requestBody1));
}

export function requestBody1FromJSON(
  jsonString: string,
): SafeParseResult<RequestBody1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBody1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBody1' from JSON`,
  );
}

/** @internal */
export const UploadRequestBody$inboundSchema: z.ZodType<
  UploadRequestBody,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => Two$inboundSchema),
  z.lazy(() => RequestBody1$inboundSchema),
]);

/** @internal */
export type UploadRequestBody$Outbound = Two$Outbound | RequestBody1$Outbound;

/** @internal */
export const UploadRequestBody$outboundSchema: z.ZodType<
  UploadRequestBody$Outbound,
  z.ZodTypeDef,
  UploadRequestBody
> = z.union([
  z.lazy(() => Two$outboundSchema),
  z.lazy(() => RequestBody1$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UploadRequestBody$ {
  /** @deprecated use `UploadRequestBody$inboundSchema` instead. */
  export const inboundSchema = UploadRequestBody$inboundSchema;
  /** @deprecated use `UploadRequestBody$outboundSchema` instead. */
  export const outboundSchema = UploadRequestBody$outboundSchema;
  /** @deprecated use `UploadRequestBody$Outbound` instead. */
  export type Outbound = UploadRequestBody$Outbound;
}

export function uploadRequestBodyToJSON(
  uploadRequestBody: UploadRequestBody,
): string {
  return JSON.stringify(
    UploadRequestBody$outboundSchema.parse(uploadRequestBody),
  );
}

export function uploadRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<UploadRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UploadRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UploadRequestBody' from JSON`,
  );
}

/** @internal */
export const UploadRequest$inboundSchema: z.ZodType<
  UploadRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  "X-Log10-Organization": z.string().optional(),
  RequestBody: z.union([
    z.lazy(() => Two$inboundSchema),
    z.lazy(() => RequestBody1$inboundSchema),
  ]),
}).transform((v) => {
  return remap$(v, {
    "X-Log10-Organization": "xLog10Organization",
    "RequestBody": "requestBody",
  });
});

/** @internal */
export type UploadRequest$Outbound = {
  "X-Log10-Organization"?: string | undefined;
  RequestBody: Two$Outbound | RequestBody1$Outbound;
};

/** @internal */
export const UploadRequest$outboundSchema: z.ZodType<
  UploadRequest$Outbound,
  z.ZodTypeDef,
  UploadRequest
> = z.object({
  xLog10Organization: z.string().optional(),
  requestBody: z.union([
    z.lazy(() => Two$outboundSchema),
    z.lazy(() => RequestBody1$outboundSchema),
  ]),
}).transform((v) => {
  return remap$(v, {
    xLog10Organization: "X-Log10-Organization",
    requestBody: "RequestBody",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UploadRequest$ {
  /** @deprecated use `UploadRequest$inboundSchema` instead. */
  export const inboundSchema = UploadRequest$inboundSchema;
  /** @deprecated use `UploadRequest$outboundSchema` instead. */
  export const outboundSchema = UploadRequest$outboundSchema;
  /** @deprecated use `UploadRequest$Outbound` instead. */
  export type Outbound = UploadRequest$Outbound;
}

export function uploadRequestToJSON(uploadRequest: UploadRequest): string {
  return JSON.stringify(UploadRequest$outboundSchema.parse(uploadRequest));
}

export function uploadRequestFromJSON(
  jsonString: string,
): SafeParseResult<UploadRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UploadRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UploadRequest' from JSON`,
  );
}

/** @internal */
export const UploadResponse$inboundSchema: z.ZodType<
  UploadResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  HttpMeta: HTTPMetadata$inboundSchema,
  Feedback: Feedback$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "HttpMeta": "httpMeta",
    "Feedback": "feedback",
  });
});

/** @internal */
export type UploadResponse$Outbound = {
  HttpMeta: HTTPMetadata$Outbound;
  Feedback?: Feedback$Outbound | undefined;
};

/** @internal */
export const UploadResponse$outboundSchema: z.ZodType<
  UploadResponse$Outbound,
  z.ZodTypeDef,
  UploadResponse
> = z.object({
  httpMeta: HTTPMetadata$outboundSchema,
  feedback: Feedback$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    httpMeta: "HttpMeta",
    feedback: "Feedback",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UploadResponse$ {
  /** @deprecated use `UploadResponse$inboundSchema` instead. */
  export const inboundSchema = UploadResponse$inboundSchema;
  /** @deprecated use `UploadResponse$outboundSchema` instead. */
  export const outboundSchema = UploadResponse$outboundSchema;
  /** @deprecated use `UploadResponse$Outbound` instead. */
  export type Outbound = UploadResponse$Outbound;
}

export function uploadResponseToJSON(uploadResponse: UploadResponse): string {
  return JSON.stringify(UploadResponse$outboundSchema.parse(uploadResponse));
}

export function uploadResponseFromJSON(
  jsonString: string,
): SafeParseResult<UploadResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UploadResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UploadResponse' from JSON`,
  );
}
