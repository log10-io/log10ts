/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { remap as remap$ } from "../../lib/primitives";
import {
    ChatCompletionResponseMessage,
    ChatCompletionResponseMessage$,
} from "./chatcompletionresponsemessage";
import {
    ChatCompletionTokenLogprob,
    ChatCompletionTokenLogprob$,
} from "./chatcompletiontokenlogprob";
import { CompletionUsage, CompletionUsage$ } from "./completionusage";
import * as z from "zod";

/**
 * The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
 *
 * @remarks
 * `length` if the maximum number of tokens specified in the request was reached,
 * `content_filter` if content was omitted due to a flag from our content filters,
 * `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
 *
 */
export enum FinishReason {
    Stop = "stop",
    Length = "length",
    ToolCalls = "tool_calls",
    ContentFilter = "content_filter",
    FunctionCall = "function_call",
}

/**
 * Log probability information for the choice.
 */
export type Logprobs = {
    /**
     * A list of message content tokens with log probability information.
     */
    content: Array<ChatCompletionTokenLogprob> | null;
};

export type Choices = {
    /**
     * The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
     *
     * @remarks
     * `length` if the maximum number of tokens specified in the request was reached,
     * `content_filter` if content was omitted due to a flag from our content filters,
     * `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
     *
     */
    finishReason: FinishReason;
    /**
     * The index of the choice in the list of choices.
     */
    index: number;
    /**
     * A chat completion message generated by the model.
     */
    message: ChatCompletionResponseMessage;
    /**
     * Log probability information for the choice.
     */
    logprobs: Logprobs | null;
};

/**
 * The object type, which is always `chat.completion`.
 */
export enum ObjectT {
    ChatCompletion = "chat.completion",
}

/**
 * Represents a chat completion response returned by model, based on the provided input.
 */
export type CreateChatCompletionResponse = {
    /**
     * A unique identifier for the chat completion.
     */
    id: string;
    /**
     * A list of chat completion choices. Can be more than one if `n` is greater than 1.
     */
    choices: Array<Choices>;
    /**
     * The Unix timestamp (in seconds) of when the chat completion was created.
     */
    created: number;
    /**
     * The model used for the chat completion.
     */
    model: string;
    /**
     * This fingerprint represents the backend configuration that the model runs with.
     *
     * @remarks
     *
     * Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.
     *
     */
    systemFingerprint?: string | undefined;
    /**
     * The object type, which is always `chat.completion`.
     */
    object: ObjectT;
    /**
     * Usage statistics for the completion request.
     */
    usage?: CompletionUsage | undefined;
};

/** @internal */
export namespace FinishReason$ {
    export const inboundSchema = z.nativeEnum(FinishReason);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace Logprobs$ {
    export const inboundSchema: z.ZodType<Logprobs, z.ZodTypeDef, unknown> = z.object({
        content: z.nullable(z.array(ChatCompletionTokenLogprob$.inboundSchema)),
    });

    export type Outbound = {
        content: Array<ChatCompletionTokenLogprob$.Outbound> | null;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Logprobs> = z.object({
        content: z.nullable(z.array(ChatCompletionTokenLogprob$.outboundSchema)),
    });
}

/** @internal */
export namespace Choices$ {
    export const inboundSchema: z.ZodType<Choices, z.ZodTypeDef, unknown> = z
        .object({
            finish_reason: FinishReason$.inboundSchema,
            index: z.number().int(),
            message: ChatCompletionResponseMessage$.inboundSchema,
            logprobs: z.nullable(z.lazy(() => Logprobs$.inboundSchema)),
        })
        .transform((v) => {
            return remap$(v, {
                finish_reason: "finishReason",
            });
        });

    export type Outbound = {
        finish_reason: string;
        index: number;
        message: ChatCompletionResponseMessage$.Outbound;
        logprobs: Logprobs$.Outbound | null;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, Choices> = z
        .object({
            finishReason: FinishReason$.outboundSchema,
            index: z.number().int(),
            message: ChatCompletionResponseMessage$.outboundSchema,
            logprobs: z.nullable(z.lazy(() => Logprobs$.outboundSchema)),
        })
        .transform((v) => {
            return remap$(v, {
                finishReason: "finish_reason",
            });
        });
}

/** @internal */
export namespace ObjectT$ {
    export const inboundSchema = z.nativeEnum(ObjectT);
    export const outboundSchema = inboundSchema;
}

/** @internal */
export namespace CreateChatCompletionResponse$ {
    export const inboundSchema: z.ZodType<CreateChatCompletionResponse, z.ZodTypeDef, unknown> = z
        .object({
            id: z.string(),
            choices: z.array(z.lazy(() => Choices$.inboundSchema)),
            created: z.number().int(),
            model: z.string(),
            system_fingerprint: z.string().optional(),
            object: ObjectT$.inboundSchema,
            usage: CompletionUsage$.inboundSchema.optional(),
        })
        .transform((v) => {
            return remap$(v, {
                system_fingerprint: "systemFingerprint",
            });
        });

    export type Outbound = {
        id: string;
        choices: Array<Choices$.Outbound>;
        created: number;
        model: string;
        system_fingerprint?: string | undefined;
        object: string;
        usage?: CompletionUsage$.Outbound | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, CreateChatCompletionResponse> = z
        .object({
            id: z.string(),
            choices: z.array(z.lazy(() => Choices$.outboundSchema)),
            created: z.number().int(),
            model: z.string(),
            systemFingerprint: z.string().optional(),
            object: ObjectT$.outboundSchema,
            usage: CompletionUsage$.outboundSchema.optional(),
        })
        .transform((v) => {
            return remap$(v, {
                systemFingerprint: "system_fingerprint",
            });
        });
}
