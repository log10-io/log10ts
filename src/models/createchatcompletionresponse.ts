/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { remap as remap$ } from "../lib/primitives.js";
import {
    ChatCompletionResponseMessage,
    ChatCompletionResponseMessage$inboundSchema,
    ChatCompletionResponseMessage$Outbound,
    ChatCompletionResponseMessage$outboundSchema,
} from "./chatcompletionresponsemessage.js";
import {
    ChatCompletionTokenLogprob,
    ChatCompletionTokenLogprob$inboundSchema,
    ChatCompletionTokenLogprob$Outbound,
    ChatCompletionTokenLogprob$outboundSchema,
} from "./chatcompletiontokenlogprob.js";
import {
    CompletionUsage,
    CompletionUsage$inboundSchema,
    CompletionUsage$Outbound,
    CompletionUsage$outboundSchema,
} from "./completionusage.js";
import * as z from "zod";

/**
 * The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
 *
 * @remarks
 * `length` if the maximum number of tokens specified in the request was reached,
 * `content_filter` if content was omitted due to a flag from our content filters,
 * `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
 *
 */
export enum FinishReason {
    Stop = "stop",
    Length = "length",
    ToolCalls = "tool_calls",
    ContentFilter = "content_filter",
    FunctionCall = "function_call",
}

/**
 * Log probability information for the choice.
 */
export type Logprobs = {
    /**
     * A list of message content tokens with log probability information.
     */
    content: Array<ChatCompletionTokenLogprob> | null;
};

export type Choices = {
    /**
     * The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,
     *
     * @remarks
     * `length` if the maximum number of tokens specified in the request was reached,
     * `content_filter` if content was omitted due to a flag from our content filters,
     * `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.
     *
     */
    finishReason: FinishReason;
    /**
     * The index of the choice in the list of choices.
     */
    index: number;
    /**
     * A chat completion message generated by the model.
     */
    message: ChatCompletionResponseMessage;
    /**
     * Log probability information for the choice.
     */
    logprobs: Logprobs | null;
};

/**
 * The object type, which is always `chat.completion`.
 */
export enum ObjectT {
    ChatCompletion = "chat.completion",
}

/**
 * Represents a chat completion response returned by model, based on the provided input.
 */
export type CreateChatCompletionResponse = {
    /**
     * A unique identifier for the chat completion.
     */
    id: string;
    /**
     * A list of chat completion choices. Can be more than one if `n` is greater than 1.
     */
    choices: Array<Choices>;
    /**
     * The Unix timestamp (in seconds) of when the chat completion was created.
     */
    created: number;
    /**
     * The ID of the [Model](/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used.
     */
    model?: any | null | undefined;
    /**
     * This fingerprint represents the backend configuration that the model runs with.
     *
     * @remarks
     *
     * Can be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.
     *
     */
    systemFingerprint?: string | undefined;
    /**
     * The object type, which is always `chat.completion`.
     */
    object: ObjectT;
    /**
     * Usage statistics for the completion request.
     */
    usage?: CompletionUsage | undefined;
};

/** @internal */
export const FinishReason$inboundSchema: z.ZodNativeEnum<typeof FinishReason> =
    z.nativeEnum(FinishReason);

/** @internal */
export const FinishReason$outboundSchema: z.ZodNativeEnum<typeof FinishReason> =
    FinishReason$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FinishReason$ {
    /** @deprecated use `FinishReason$inboundSchema` instead. */
    export const inboundSchema = FinishReason$inboundSchema;
    /** @deprecated use `FinishReason$outboundSchema` instead. */
    export const outboundSchema = FinishReason$outboundSchema;
}

/** @internal */
export const Logprobs$inboundSchema: z.ZodType<Logprobs, z.ZodTypeDef, unknown> = z.object({
    content: z.nullable(z.array(ChatCompletionTokenLogprob$inboundSchema)),
});

/** @internal */
export type Logprobs$Outbound = {
    content: Array<ChatCompletionTokenLogprob$Outbound> | null;
};

/** @internal */
export const Logprobs$outboundSchema: z.ZodType<Logprobs$Outbound, z.ZodTypeDef, Logprobs> =
    z.object({
        content: z.nullable(z.array(ChatCompletionTokenLogprob$outboundSchema)),
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Logprobs$ {
    /** @deprecated use `Logprobs$inboundSchema` instead. */
    export const inboundSchema = Logprobs$inboundSchema;
    /** @deprecated use `Logprobs$outboundSchema` instead. */
    export const outboundSchema = Logprobs$outboundSchema;
    /** @deprecated use `Logprobs$Outbound` instead. */
    export type Outbound = Logprobs$Outbound;
}

/** @internal */
export const Choices$inboundSchema: z.ZodType<Choices, z.ZodTypeDef, unknown> = z
    .object({
        finish_reason: FinishReason$inboundSchema,
        index: z.number().int(),
        message: ChatCompletionResponseMessage$inboundSchema,
        logprobs: z.nullable(z.lazy(() => Logprobs$inboundSchema)),
    })
    .transform((v) => {
        return remap$(v, {
            finish_reason: "finishReason",
        });
    });

/** @internal */
export type Choices$Outbound = {
    finish_reason: string;
    index: number;
    message: ChatCompletionResponseMessage$Outbound;
    logprobs: Logprobs$Outbound | null;
};

/** @internal */
export const Choices$outboundSchema: z.ZodType<Choices$Outbound, z.ZodTypeDef, Choices> = z
    .object({
        finishReason: FinishReason$outboundSchema,
        index: z.number().int(),
        message: ChatCompletionResponseMessage$outboundSchema,
        logprobs: z.nullable(z.lazy(() => Logprobs$outboundSchema)),
    })
    .transform((v) => {
        return remap$(v, {
            finishReason: "finish_reason",
        });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Choices$ {
    /** @deprecated use `Choices$inboundSchema` instead. */
    export const inboundSchema = Choices$inboundSchema;
    /** @deprecated use `Choices$outboundSchema` instead. */
    export const outboundSchema = Choices$outboundSchema;
    /** @deprecated use `Choices$Outbound` instead. */
    export type Outbound = Choices$Outbound;
}

/** @internal */
export const ObjectT$inboundSchema: z.ZodNativeEnum<typeof ObjectT> = z.nativeEnum(ObjectT);

/** @internal */
export const ObjectT$outboundSchema: z.ZodNativeEnum<typeof ObjectT> = ObjectT$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ObjectT$ {
    /** @deprecated use `ObjectT$inboundSchema` instead. */
    export const inboundSchema = ObjectT$inboundSchema;
    /** @deprecated use `ObjectT$outboundSchema` instead. */
    export const outboundSchema = ObjectT$outboundSchema;
}

/** @internal */
export const CreateChatCompletionResponse$inboundSchema: z.ZodType<
    CreateChatCompletionResponse,
    z.ZodTypeDef,
    unknown
> = z
    .object({
        id: z.string(),
        choices: z.array(z.lazy(() => Choices$inboundSchema)),
        created: z.number().int(),
        model: z.nullable(z.any()).optional(),
        system_fingerprint: z.string().optional(),
        object: ObjectT$inboundSchema,
        usage: CompletionUsage$inboundSchema.optional(),
    })
    .transform((v) => {
        return remap$(v, {
            system_fingerprint: "systemFingerprint",
        });
    });

/** @internal */
export type CreateChatCompletionResponse$Outbound = {
    id: string;
    choices: Array<Choices$Outbound>;
    created: number;
    model?: any | null | undefined;
    system_fingerprint?: string | undefined;
    object: string;
    usage?: CompletionUsage$Outbound | undefined;
};

/** @internal */
export const CreateChatCompletionResponse$outboundSchema: z.ZodType<
    CreateChatCompletionResponse$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionResponse
> = z
    .object({
        id: z.string(),
        choices: z.array(z.lazy(() => Choices$outboundSchema)),
        created: z.number().int(),
        model: z.nullable(z.any()).optional(),
        systemFingerprint: z.string().optional(),
        object: ObjectT$outboundSchema,
        usage: CompletionUsage$outboundSchema.optional(),
    })
    .transform((v) => {
        return remap$(v, {
            systemFingerprint: "system_fingerprint",
        });
    });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateChatCompletionResponse$ {
    /** @deprecated use `CreateChatCompletionResponse$inboundSchema` instead. */
    export const inboundSchema = CreateChatCompletionResponse$inboundSchema;
    /** @deprecated use `CreateChatCompletionResponse$outboundSchema` instead. */
    export const outboundSchema = CreateChatCompletionResponse$outboundSchema;
    /** @deprecated use `CreateChatCompletionResponse$Outbound` instead. */
    export type Outbound = CreateChatCompletionResponse$Outbound;
}
